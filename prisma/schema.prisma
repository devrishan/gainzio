// Prisma schema for Gainzio platform
// Database: MySQL

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("POSTGRES_PRISMA_URL") // uses connection pooling
  directUrl = env("POSTGRES_URL_NON_POOLING") // uses a direct connection
}

enum Role {
  USER
  ADMIN
  VERIFIER
  PAYOUT_MANAGER
  SUPER_ADMIN
  SUPPORT
  DESIGNER
}

enum SubmissionStatus {
  SUBMITTED
  REVIEWING
  APPROVED
  REJECTED
  DELETED
}

enum WithdrawalStatus {
  PENDING
  APPROVED
  REJECTED
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

enum NotificationType {
  TASK_APPROVED
  TASK_REJECTED
  WITHDRAWAL_UPDATE
  REFERRAL_VERIFIED
  RANK_UPGRADE
  STREAK_WARNING
  EMAIL_VERIFICATION
  PASSWORD_RESET
}

enum Rank {
  NEWBIE
  PRO
  ELITE
  MASTER
}

model User {
  id            String    @id @default(cuid())
  phone         String?   @unique // Made optional for Google Auth users (who might only have email initially)
  email         String?   @unique
  username      String?   @unique
  name          String? // NextAuth standard
  image         String? // NextAuth standard
  emailVerified DateTime? // NextAuth standard
  role          Role      @default(USER)
  // Auth-related
  // Auth-related
  // hashedPassword removed in favor of password_hash
  password_hash String? // Unified field

  phone_verified Boolean @default(false)

  // Security Locking
  failed_attempts Int       @default(0)
  lock_until      DateTime?
  is_locked       Boolean   @default(false)

  // Tracking & Privacy
  last_login_at      DateTime?
  last_login_ip_hash String?
  last_device_hash   String?

  emailVerifiedAt        DateTime?
  emailVerificationToken String?   @unique
  
  // Profile & Targeting
  dob               DateTime?
  country           String?
  state             String?
  district          String?
  verificationLevel Int       @default(0) // 0=None, 1=Basic, 2=Identity, 3=Verified
  trustScore        Int       @default(100)
  
  // Fraud & Shadow Ban
  isShadowBanned    Boolean   @default(false)
  shadowBannedAt    DateTime?
  
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt

  // Soft delete
  deletedAt DateTime?
  isDeleted Boolean   @default(false)

  // Referral & hierarchy
  referralCode String  @unique @default(cuid()) // Ensure default for new users
  referredById String?
  referredBy   User?   @relation("UserReferrals", fields: [referredById], references: [id], onDelete: SetNull)
  referrals    User[]  @relation("UserReferrals")

  // Wallet & gamification
  wallet           Wallet?
  transactions     WalletTransaction[]
  coinTransactions CoinTransaction[]
  withdrawals      Withdrawal[]
  gamification     GamificationState?

  // Tasks
  submissions TaskSubmission[]

  // Notifications & sessions
  notifications   Notification[]
  legacySessions  LegacySession[] // Renamed from sessions
  passwordHistory PasswordHistory[]

  // NextAuth
  accounts Account[]
  sessions Session[]

  // Referrals & tree
  referralEvents     Referral[] @relation("ReferrerEvents")
  referredUserEvents Referral[] @relation("ReferredUser")

  // New relations
  preferences    UserPreference?
  paymentMethods PaymentMethod[]
  activityLogs   ActivityLog[]
  fraudLogs      FraudLog[]
  leaderboards   Leaderboard[]
  auditLogs      AuditLog[]      @relation("AuditLogActor")

  // Reviewer relation
  reviewedSubmissions TaskSubmission[] @relation("SubmissionReviewer")

  // Product suggestions
  productSuggestions ProductSuggestion[]

  // Support
  supportTickets   SupportTicket[]
  supportMessages  SupportMessage[]
  
  // Trading
  futurePositions  FuturePosition[]

  // Ads
  adImpressions    AdImpression[]
  adClicks         AdClick[]

  @@index([referredById])
  @@index([role])
  @@index([phone])
  @@index([email])
  @@index([isDeleted, deletedAt])
}

model PasswordHistory {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  hash      String
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([createdAt])
}

// Renamed from Session to avoid conflict with NextAuth
model LegacySession {
  id             String    @id @default(cuid())
  userId         String
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  refreshToken   String    @unique
  createdAt      DateTime  @default(now())
  expiresAt      DateTime
  lastActivityAt DateTime?
  userAgent      String?
  ipAddress      String?
  revokedAt      DateTime?
  revokedReason  String?

  @@index([userId])
  @@index([expiresAt])
  @@index([userId, revokedAt])
}

// NextAuth Models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model OtpRequest {
  id         String    @id @default(cuid())
  phone      String
  codeHash   String
  expiresAt  DateTime
  createdAt  DateTime  @default(now())
  verifiedAt DateTime?
  consumedAt DateTime?
  attempts   Int       @default(0)
  ipAddress  String?
  isBlocked  Boolean   @default(false)

  @@index([phone])
  @@index([expiresAt])
  @@index([phone, verifiedAt])
}

model Wallet {
  id            String              @id @default(cuid())
  userId        String              @unique
  user          User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  balance       Decimal             @default(0.0) @db.Decimal(10, 2)
  pendingAmount Decimal             @default(0.0) @db.Decimal(10, 2)
  withdrawable  Decimal             @default(0.0) @db.Decimal(10, 2)
  lockedAmount  Decimal             @default(0.0) @db.Decimal(10, 2)
  coins         Int                 @default(0)
  lockedCoins   Int                 @default(0)
  totalEarned   Decimal             @default(0.0) @db.Decimal(10, 2)
  currency      String              @default("INR") @db.VarChar(3)
  updatedAt     DateTime            @updatedAt
  transactions  WalletTransaction[]
}

model WalletTransaction {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  walletId  String
  wallet    Wallet   @relation(fields: [walletId], references: [id], onDelete: Cascade)
  amount    Decimal  @db.Decimal(10, 2)
  type      String
  metadata  Json?
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([walletId])
  @@index([type])
  @@index([createdAt])
  @@index([userId, createdAt])
}

model CoinTransaction {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  amount      Int
  type        String // EARN, SPEND
  status      String   @default("COMPLETED") // LOCKED, COMPLETED
  unlocksAt   DateTime?
  description String
  source      String? // STREAK_FREEZE, TASK_PEEK, TASK_REWARD, etc.
  metadata    Json?
  createdAt   DateTime @default(now())

  @@index([userId])
  @@index([type])
  @@index([source])
  @@index([createdAt])
  @@index([status, unlocksAt])
}

model Withdrawal {
  id          String           @id @default(cuid())
  userId      String
  user        User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  amount      Decimal          @db.Decimal(10, 2)
  status      WithdrawalStatus @default(PENDING)
  upiId       String
  upiQrUrl    String?
  requestedAt DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  processedAt DateTime?
  txId        String?
  receiptUrl  String?
  notes       String?          @db.Text
  metadata    Json?

  @@index([userId])
  @@index([status])
  @@index([requestedAt])
  @@index([status, requestedAt])
}

model TaskCategory {
  id        String         @id @default(cuid())
  name      String         @unique
  slug      String         @unique
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
  deletedAt DateTime?
  isDeleted Boolean        @default(false)
  tasks     Task[]
  templates TaskTemplate[]
}


enum TaskStatus {
  DRAFT
  SCHEDULED
  ACTIVE
  PAUSED
  COMPLETED
  ARCHIVED
}

model Task {
  id              String               @id @default(cuid())
  title           String
  taskType        String               @default("STANDARD") // STANDARD, SOCIAL_MEDIA
  slug            String               @unique
  description     String               @db.Text
  categoryId      String
  category        TaskCategory         @relation(fields: [categoryId], references: [id], onDelete: Restrict)
  rewardAmount    Decimal              @db.Decimal(10, 2)
  rewardCoins     Int                  @default(0)
  difficulty      String
  minRank         Rank                 @default(NEWBIE)
  targeting       Json?                // { minAge, districts: [], verifiedOnly, platform... }
  proofConfig     Json?                // { screenshotCount, duration... }
  status          TaskStatus           @default(DRAFT)
  startTime       DateTime?
  isActive        Boolean              @default(true) // Deprecated in favor of status, keeping for backward compat temporarily
  maxSubmissions  Int?
  expiresAt       DateTime?
  priority        Int                  @default(0)
  deletedAt       DateTime?
  isDeleted       Boolean              @default(false)
  createdAt       DateTime             @default(now())
  updatedAt       DateTime             @updatedAt
  submissions     TaskSubmission[]
  completionRules TaskCompletionRule[]

  @@index([categoryId])
  @@index([status])
  @@index([slug])
  @@index([categoryId, status])
  @@index([isDeleted, deletedAt])
}

model TaskSubmission {
  id           String           @id @default(cuid())
  taskId       String
  task         Task             @relation(fields: [taskId], references: [id], onDelete: Cascade)
  userId       String
  user         User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  status       SubmissionStatus @default(SUBMITTED)
  proofUrl     String
  proofHash    String?          // MD5/SHA256 hash of image to detect duplicates
  proofType    String?
  proofData    Json?            // { startScreenshot, endScreenshot, timestamp... }
  notes        String?          @db.Text
  reviewedById String?
  reviewedBy   User?            @relation("SubmissionReviewer", fields: [reviewedById], references: [id], onDelete: SetNull)
  submittedAt  DateTime         @default(now())
  reviewedAt   DateTime?
  metadata     Json?

  @@index([taskId])
  @@index([userId])
  @@index([status])
  @@index([submittedAt])
  @@index([proofHash])
  @@index([userId, status])
  @@index([taskId, status])
}

// Multi-level referral events (level 1/2/3, amounts, etc.)
model Referral {
  id               String   @id @default(cuid())
  referrerId       String
  referrer         User     @relation("ReferrerEvents", fields: [referrerId], references: [id], onDelete: Cascade)
  referredUserId   String
  referredUser     User     @relation("ReferredUser", fields: [referredUserId], references: [id], onDelete: Cascade)
  level            Int
  commissionAmount Decimal  @default(0.0) @db.Decimal(10, 2)
  status           String   @default("pending")
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@index([referrerId])
  @@index([referredUserId])
  @@index([level])
  @@index([status])
  @@index([referrerId, status])
}

model Notification {
  id        String           @id @default(cuid())
  userId    String
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      NotificationType
  title     String
  body      String           @db.Text
  data      Json?
  isRead    Boolean          @default(false)
  createdAt DateTime         @default(now())

  @@index([userId])
  @@index([isRead])
  @@index([createdAt])
  @@index([userId, isRead, createdAt])
}

model GamificationState {
  id              String        @id @default(cuid())
  userId          String        @unique
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  xp              Int           @default(0)
  rank            Rank          @default(NEWBIE)
  streakDays      Int           @default(0)
  smartScore      Int           @default(0)
  lastScoreUpdate DateTime      @default(now())
  lastLoginAt     DateTime?
  badges          BadgeOnUser[]
  inventory       UserInventory[]

  @@index([rank])
  @@index([xp])
  @@index([smartScore])
}

model ShopItem {
  id          String   @id @default(cuid())
  name        String
  description String   @db.Text
  cost        Int
  type        String   // PERK, CONSUMABLE, COSMETIC
  icon        String?  // Lucide icon name or URL
  isActive    Boolean  @default(true)
  metadata    Json?    // e.g. { "duration": 24h }
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  inventory   UserInventory[]
}

model UserInventory {
  id             String            @id @default(cuid())
  userId         String
  gamificationId String
  gamification   GamificationState @relation(fields: [gamificationId], references: [id], onDelete: Cascade)
  shopItemId     String
  shopItem       ShopItem          @relation(fields: [shopItemId], references: [id], onDelete: Cascade)
  quantity       Int               @default(1)
  remainingUses  Int?              // For consummables like "5 Task Peeks"
  acquiredAt     DateTime          @default(now())
  expiresAt      DateTime?

  @@unique([gamificationId, shopItemId])
  @@index([userId])
}

model Badge {
  id          String        @id @default(cuid())
  code        String        @unique
  name        String
  description String        @db.Text
  icon        String?
  createdAt   DateTime      @default(now())
  users       BadgeOnUser[]
}

model BadgeOnUser {
  id             String            @id @default(cuid())
  badgeId        String
  badge          Badge             @relation(fields: [badgeId], references: [id], onDelete: Cascade)
  gamificationId String
  gamification   GamificationState @relation(fields: [gamificationId], references: [id], onDelete: Cascade)
  earnedAt       DateTime          @default(now())
}

// Spark Wall events (for real-time feed)
model SparkEvent {
  id        String   @id @default(cuid())
  type      String
  message   String   @db.Text
  data      Json?
  isPublic  Boolean  @default(true)
  createdAt DateTime @default(now())

  @@index([createdAt])
  @@index([type, createdAt])
}

// Minimal audit logs, especially for payouts
model AuditLog {
  id         String   @id @default(cuid())
  actorId    String?
  actor      User?    @relation("AuditLogActor", fields: [actorId], references: [id], onDelete: SetNull)
  action     String
  entityId   String?
  entityType String?
  metadata   Json?
  createdAt  DateTime @default(now())

  @@index([actorId])
}

model PromoCode {
  id          String    @id @default(cuid())
  code        String    @unique
  description String?
  value       Decimal   @db.Decimal(10, 2)
  type        String    @default("FIXED") // FIXED or PERCENTAGE
  maxUses     Int       @default(1)
  currentUses Int       @default(0)
  expiresAt   DateTime?
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  createdBy   String?

  @@index([code])
}

model Blacklist {
  id        String   @id @default(cuid())
  type      String // IP, EMAIL, WALLET
  value     String
  reason    String?
  createdAt DateTime @default(now())
  createdBy String?

  @@unique([type, value])
  @@index([value])
}

// Rate limiting for API and auth
model RateLimit {
  id          String   @id @default(cuid())
  identifier  String // phone, email, IP, userId
  type        String // "otp", "login", "api"
  count       Int      @default(1)
  windowStart DateTime
  expiresAt   DateTime
  createdAt   DateTime @default(now())

  @@index([identifier, type, windowStart])
  @@index([expiresAt])
}

// User preferences
model UserPreference {
  id            String   @id @default(cuid())
  userId        String   @unique
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  language      String   @default("en") @db.VarChar(10)
  timezone      String   @default("UTC")
  notifications Json? // notification preferences
  aiPreferences Json? // { chat: boolean, autoSuggestions: boolean, helpTips: boolean }
  theme         String   @default("light")
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

// Payment methods for users
model PaymentMethod {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  type        String // "UPI", "BANK", "WALLET"
  upiId       String?
  bankAccount Json?
  isDefault   Boolean  @default(false)
  isVerified  Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId, isDefault])
}

// Task templates
model TaskTemplate {
  id           String       @id @default(cuid())
  name         String
  description  String       @db.Text
  categoryId   String
  category     TaskCategory @relation(fields: [categoryId], references: [id], onDelete: Restrict)
  rewardAmount Decimal      @db.Decimal(10, 2)
  rewardCoins  Int          @default(0)
  difficulty   String
  isActive     Boolean      @default(true)
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt

  @@index([categoryId, isActive])
}

// Activity logs (enhanced)
model ActivityLog {
  id         String   @id @default(cuid())
  userId     String?
  user       User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  action     String
  entityType String?
  entityId   String?
  metadata   Json?
  createdAt  DateTime @default(now())
}

model SupportTicket {
  id        String           @id @default(cuid())
  userId    String
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  subject   String
  status    String           @default("OPEN") // OPEN, ANSWERED, CLOSED
  priority  String           @default("NORMAL")
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  messages  SupportMessage[]

  @@index([userId])
  @@index([status])
}

model SupportMessage {
  id        String        @id @default(cuid())
  ticketId  String
  ticket    SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  senderId  String
  sender    User          @relation(fields: [senderId], references: [id], onDelete: Cascade)
  message   String        @db.Text
  createdAt DateTime      @default(now())

  @@index([ticketId])
}



// Leaderboard
model Leaderboard {
  id          String    @id @default(cuid())
  period      String // "daily", "weekly", "monthly", "alltime"
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  rank        Int
  score       Decimal   @db.Decimal(10, 2)
  periodStart DateTime
  periodEnd   DateTime?
  createdAt   DateTime  @default(now())

  @@unique([period, userId, periodStart])
  @@index([period, rank])
  @@index([period, score])
}

// Task completion rules
model TaskCompletionRule {
  id        String   @id @default(cuid())
  taskId    String
  task      Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  ruleType  String // "daily_limit", "cooldown", "prerequisite"
  value     Json
  createdAt DateTime @default(now())

  @@index([taskId])
}

// Product suggestions from users
model ProductSuggestion {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  productName String
  platform    String // "amazon", "flipkart", etc.
  category    String?
  amount      Decimal? @db.Decimal(10, 2)
  orderId     String?
  files       Json? // S3 URLs array
  status      String   @default("pending") // pending, approved, rejected, converted
  metadata    Json?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId])
  @@index([status])
  @@index([platform])
  @@index([status, createdAt])
}

model AdZone {
  id          String       @id @default(cuid())
  name        String       @unique // e.g. "dashboard_sidebar", "mobile_footer"
  slug        String       @unique
  width       Int
  height      Int
  description String?
  isActive    Boolean      @default(true)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  campaigns   AdCampaign[]
}

model AdCampaign {
  id          String   @id @default(cuid())
  name        String
  advertiser  String?
  imageUrl    String
  targetUrl   String
  zones       AdZone[]
  
  // Scheduling & Budgets
  startDate   DateTime @default(now())
  endDate     DateTime?
  dailyBudget Int?     // Max impressions/day
  totalBudget Int?     // Max impressions total
  
  // Stats
  views       Int      @default(0)
  clicks      Int      @default(0)
  
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  impressions AdImpression[]
  adClicks    AdClick[]

  @@index([isActive])
}

model AdImpression {
  id         String     @id @default(uuid())
  campaignId String
  campaign   AdCampaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  userId     String?
  user       User?      @relation(fields: [userId], references: [id], onDelete: SetNull)
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime   @default(now())

  @@index([campaignId])
  @@index([createdAt])
}

model AdClick {
  id         String     @id @default(uuid())
  campaignId String
  campaign   AdCampaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  userId     String?
  user       User?      @relation(fields: [userId], references: [id], onDelete: SetNull)
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime   @default(now())

  @@index([campaignId])
  @@index([createdAt])
}

model SystemConfig {
  id          String   @id @default(cuid())
  key         String   @unique // e.g. "rank_thresholds", "reward_formulas"
  value       Json // The config object
  description String?  @db.Text
  updatedBy   String?
  updatedAt   DateTime @updatedAt

  @@index([key])
}

model AssetPrice {
  id          String   @id @default(cuid())
  symbol      String   @unique
  price       Decimal  @db.Decimal(10, 2)
  lastUpdated DateTime @default(now())

  @@index([symbol])
}

model FraudLog {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  type        String   // IP_MISMATCH, FAST_SUBMISSION, DUPLICATE_PROOF, MULTIPLE_ACCOUNTS
  severity    String   @default("MEDIUM") // LOW, MEDIUM, HIGH, CRITICAL
  scoreImpact Int      @default(0) // How much it affected trust score (negative value)
  details     String?  @db.Text
  metadata    Json?
  createdAt   DateTime @default(now())
  resolved    Boolean  @default(false)

  @@index([userId])
  @@index([type])
  @@index([createdAt])
  @@index([severity])
}

model FuturePosition {
  id         String    @id @default(cuid())
  userId     String
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  symbol     String
  type       String    // LONG, SHORT
  leverage   Int
  margin     Int       // Uses XP
  entryPrice Decimal   @db.Decimal(10, 2)
  volume     Int
  status     String    // OPEN, CLOSED
  pnl        Int?
  createdAt  DateTime  @default(now())
  closedAt   DateTime?

  @@index([userId])
  @@index([status])
}
